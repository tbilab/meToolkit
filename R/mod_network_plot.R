#' Interactive individual-level data network diagram of patients to codes
#'
#' @param id Unique id of module
#' @param height How tall we want this module to be in css units (defaults to '500px')
#' @param snp_colors A three element array of colors corresponding to the color of patient nodes and their snp status in order of 0,1,2 copies of minor allele.
#' @param div_class A character string containing a class name for the entire plot to be wrapped in. This can then be used to style with external css. Defaults to 'network_plot'.
#'
#' @return HTML tag containing interactive network
#' @export
#'
#' @examples
#'
#' network_plot_UI('mycomorbiditynetwork_plot', '100%')
network_plot_UI <- function(
  id,
  height = '500px',
  snp_colors = c('#bdbdbd','#fcae91', '#a50f15'),
  div_class = 'network_plot'
) {
  ns <- NS(id)

  # CSS Styles
  rounded_span <- function(color){
    glue::glue("
      border-radius: 15px;
      padding: 1px 6px;
      background: {color};")
  }
  header_style <- glue::glue("
    height: 10%;
    display: grid;
    grid-template-columns: 1fr 1fr;
    padding: 8px 10px;
    border-style: solid;
    border-width: 1px 0px;
    border-color: grey; ")

  tagList(
    div(
      class = div_class,
      style = glue::glue("height: {height};"),
      div(style = header_style,
        div(
          checkboxInput(
            ns("snp_filter"),
            label = "Just minor-allele carriers",
            value = FALSE
          )
        ),
        div(style = 'text-align: right;',
          span('Copies of minor allele:'),
          span(style=rounded_span(snp_colors[1]), "0"),
          span(style=rounded_span(snp_colors[2]), "1"),
          span(style=rounded_span(snp_colors[3]), "2")
        )
      ),
      r2d3::d3Output(ns("plot"), height = "90%")
    )
  )
}
#' Server function of snp info panel
#'
#' @param input,output,session Auto-filled by callModule | ignore
#' @param network_data Reactive object containing individual network data as generated by \code{meToolkit::makeNetworkData}
#' @param snp_filter Reactive object containing boolean containing info on if we've filtered by snp or not.
#' @param viz_type Character string containing info on which type of network we want to draw. "bipartite" for a plot that puts one node type on either size, or free for a traditional force directed layout. Defaults to \code{'free'}.
#' @param update_freq How many iterations of the layout simulation are run between redrawing the viz. Set to lower value for a smoother animation, higher for better performance. Default is \code{15} frames.
#' @param action_object A \code{reactiveVal} that will be updated by the module upon isolation, deletion, or snp_filtering.
#' @return Server component of interactive network plot. Returns type-payload list with the type \code{"isolation, deletion, snp_filtering"} to the passed \code{action_object} for updating app state.
#' @export
#'
#' @examples
#' callModule(info_panel, 'info_panel', snp_name, individual_data, subset_maf)

network_plot <- function(
  input, output, session,
  network_data,
  snp_filter,
  viz_type = 'free',
  update_freq = 15,
  action_object ) {

  # send data and options to the 2d plot
  output$plot <- r2d3::renderD3({
    validate(need(network_data(), message = FALSE))

    r2d3::r2d3(
      data = jsonlite::toJSON(network_data()),
      script = system.file("d3/network_plot/index.js", package = "meToolkit"),
      container = 'div',
      dependencies = c("d3-jetpack",here('inst/d3/network_plot/helpers.js')),
      options = list(
        just_snp = snp_filter(),
        msg_loc = session$ns('message'),
        viz_type = viz_type,
        update_freq = update_freq
      )
    )
  })

  # Make sure checkbox is displaying right value
  observeEvent(snp_filter(), {
    updateCheckboxInput(session, "snp_filter", value = snp_filter())
  })


  # If we've received a message from the network viz package
  # it into the returned reactive value
  observeEvent(input$message, {
    validate(need(input$message, message = FALSE))
    action_object(input$message)
  })

  # If the snp filter toggle has been changed, send the message
  # to the reactive value
  observeEvent(input$snp_filter, {

    # Check to see if the snp filter is different than current state
    validate(need(input$snp_filter != snp_filter(), message = FALSE))

    to_return <- list(
      type = 'snp_filter_change',
      payload = input$snp_filter
    )
    action_object(to_return)
  })
}
